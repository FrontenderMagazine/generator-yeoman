# Пишем свой генератор для Yeoman

В настоящее время рабочих процессов разработки фронтенда достаточно много: 
кто-то любит препроцессоры CSS, а кто-то — не очень; кто-то любит 
CoffeeScript, а кто-то — не очень; кто-то проверяет свой код перед релизом, 
а кто-то нет… С появлением инструментов автоматизации и управления 
компонентами (вроде *Grunt*, *Bower* и им подобных) я условно делю 
процессы разработки на ручные (включающие только процессы ручного 
скаффолдинга и более механической работы с исходными файлами) и 
автоматизированные (те процессы, в которых замешано использование 
вышеперечисленных инструментов). Думаю, что вы со мной согласитесь.

Видов всего два, а реализаций много. Кто-то руками копирует 
*HTML5 Boilerplate*, кто-то копирует какую-то свою заготовку, а кто-то и вовсе 
использует *Yeoman* для скаффолдинга проекта с навинченными на него *Grunt* и 
*Bower*. Эта статья для тех, кто пользуется последним подходом или хочет 
попробовать его применить.

![Yeoman][Yeoman]

Ранее [я уже писал о том][my-old-article], что такое Yeoman и как его 
использовать. 
И в этой статье я буду полагать, что читатель ознакомился с предыдущей. 
Как вы уже знаете, Yeoman несёт в себе не просто скаффолдер проекта, а целый 
рабочий процесс, конкретную реализацию которого вы задаёте используя 
определённый генератор. К примеру, рассмотренный в предыдущей статье генератор 
`webapp` имеет наиболее общие задачи для *Grunt*, которые, скорее всего, вам 
потребуется дополнить своими специфичными задачами. 
Генераторов для Yeoman уже достаточно много, чтобы попробовать 
подобрать решение для конкретного специфичного процесса разработки. Но… Если 
ничего не нашлось, а вы всё ещё чувствуете острую необходимость в генераторе и 
полны энтузиазма, то имеет смысл написать свой.

Во-первых, сразу хочу акцентировать ваше внимание на условии — вам 
нужно писать свой генератор, если:

1. ваш рабочий процесс настолько специфичен, что требует того, что ещё не было 
разработано ранее и выложено на *GitHub* или в *npm*;
1. ваш рабочий процесс, используемый в новом проекте обязательно повторится в 
одном или нескольких следующих проектах, иначе работа над спецификой 
при написании генератора теряет свой смысл;
1. при всех перечисленных причинах вы готовы потратить неопределённое 
количество времени на поиск и тестирование подходящих вам компонентов 
(npm-пакетов и *Bower*-компонентов);
1. у вас осталось желание сделать это, не смотря на перечисленные выше пункты.
Иначе, советую не слишком утруждаться и просто воспользоваться уже имеющимся 
генератором, подправив затем *Gruntfile.js* и npm-пакеты так, чтобы это 
подходило вам.

Итак, вы всё же решили написать свой генератор. Замечательно! К делу! 
Для начала нужно понимать принцип работы любого скаффолдера. Скаффолдеру 
отдают на выполнение некоторый сценарий, содержащий описание процесса 
развёртки нового проекта в понятиях, определённых самим скаффолдером (т.е. его 
API).

Для извлечения максимальной пользы из статьи я буду показывать работающие 
примеры, которые в итоге будут собраны в генератор. Для этого нужно 
сперва сформулировать требования к рабочему процессу, который я буду 
воспроизводить в генераторе. Рассмотренный рабочий процесс несколько 
примитивен и упрощён, относительно привычного мне, но он достаточен для 
демонстрации возможностей *Yeoman*. В статье не будут рассмотрены 
все «внутренности» *Yeoman*, но эта статья станет хорошим подспорьем для 
помощи в автоматизации механических рабочих процессов, а именно — процесс 
скаффолдинга. Обзор основных функциональных частей будет несколько разбросан 
относительно структуры скрипта генератора, но структурирован относительно 
процесса работы генератора. Часть примеров будет представлена в статье. 
Слишком громоздкие примеры будут вынесены на GitHub.

Требования: 

- HTML5 Boilerplate в качестве основы; 
- возможность выбрать в процессе скаффолдинга:
	- фреймворк: *Zurb Foundation 5* или *Bootstrap 3*; 
	- использование *Sass*-версии выбранного фреймворка; 
	- опциональное включение в проект модулей *Modernizr* и *Autoprefixer*;
- подразумевается, что автоматизация всех задач в проекте выполняется через 
*Grunt*. 

## yo frontender

Как бы парадоксально это ни звучало, но существует генератор генераторов для 
*Yeoman*. Это npm-пакет (`generator-generator`), который на основе всё того же 
*Yeoman* разворачивает вам шаблон нового генератора. В целом, для начала 
работы над задуманным генератором вам необходимо установить `yo` и 
`generator-generator`. Делаем это командой

	npm install -g yo generator-generator

Как известно, все генераторы для *Yeoman* должны иметь подобное именование: 
`generator-name`, где `name` — название генератора. В дальнейшем для 
использования генератора нужно будет выполнить `yo name`. Это я к тому, что 
вам нужно определиться с названием вашего генератора и создать директорию вида 
`generator-name` (в моём случае это будет `generator-frontender`) и запустите 
из неё тот самый генератор для генераторов выполнив команду

	yo generator

*Yeoman* задаст вам пару вопросов, ответы на которые необходимы ему для 
генерации `package.json`. Позднее вы сможете подправить свои ответы именно в 
этом файле.
`package.json` может содержать зависимости, которые необходимы вашему 
генератору для скаффолдинга и некоторую дополнительную информацию о самом 
генераторе.

![Инициализация нового генератора Yeoman][generator-init]

По завершении опроса генератор создаст необходимые папки, файлы и установит 
npm-пакеты, необходимые для работы генератора. 
В итоге вы получите начальное состояние будущего генератора с несколькими 
шаблонами и конфигурационными файлами. 
У вас получится приблизительно следующая структура файлов:

	├── app
	│   ├── index.js
	│   └── templates
	│       ├── _bower.json
	│       ├── _package.json
	│       ├── editorconfig
	│       └── jshintrc
	├── node_modules 
	|	└──  /* Необходимые модули */
	├── test
	│   ├── test-creation.js
	│   └── test-load.js
	├── .editorconfig
	├── .gitattributes
	├── .gitignore
	├── .jshintrc
	├── .travis.yml
	├── LICENSE
	├── package.json
	└── README.md

На первых порах наибольший интерес будут представлять файл `index.js` и 
шаблоны — файлы из директории `app/templates`.
Предсказуемо, что главным файлом, описывающим 
логику работы вашего генератора будет являться `index.js` в директории `app`. 
Он имеет подобное содержание:

	'use strict';
	var util = require('util');
	var path = require('path');
	var yeoman = require('yeoman-generator');
	
	var FrontenderGenerator = module.exports = function FrontenderGenerator(args, options, config) {
	  yeoman.generators.Base.apply(this, arguments);
	
	  this.on('end', function () {
	    this.installDependencies({ skipInstall: options['skip-install'] });
	  });
	
	  this.pkg = JSON.parse(this.readFileAsString(path.join(__dirname, '../package.json')));
	};
	
	util.inherits(FrontenderGenerator, yeoman.generators.Base);
	
	FrontenderGenerator.prototype.askFor = function askFor() {
	  var cb = this.async();
	
	  // have Yeoman greet the user.
	  console.log(this.yeoman);
	
	  var prompts = [{
	    type: 'confirm',
	    name: 'someOption',
	    message: 'Would you like to enable this option?',
	    default: true
	  }];
	
	  this.prompt(prompts, function (props) {
	    this.someOption = props.someOption;
	
	    cb();
	  }.bind(this));
	};
	
	FrontenderGenerator.prototype.app = function app() {
	  this.mkdir('app');
	  this.mkdir('app/templates');
	
	  this.copy('_package.json', 'package.json');
	  this.copy('_bower.json', 'bower.json');
	};
	
	FrontenderGenerator.prototype.projectfiles = function projectfiles() {
	  this.copy('editorconfig', '.editorconfig');
	  this.copy('jshintrc', '.jshintrc');
	};

Сейчас генератор обладает наименьшим функционалом — он может создать пару 
директорий и скопировать туда несколько файлов из директории с шаблонами. 
Чтобы было удобнее продолжать процесс разработки генератора, советую выполнить 
команду `npm link` в директории генератора. Команда создаст символическую 
ссылку на генератор и поместит её в директорию глобальных npm-пакетов, что 
сделает ваш генератор доступным для выполнения из любого каталога на жёстком 
диске. Хотя физически директория генератора не обязательно должна будет 
находиться в директории для глобальных модулей.

Можете попробовать запустить генератор. Делается это, конечно же, с помощью 
команды `yo name`. У меня это будет `yo frontender`.
*Yeoman* спросит вас «Would you like to enable this option?». Это тестовый 
вопрос. Ответ на него ни на что не влияет и в ходе выполнения скаффолдинга ваш 
генератор создаст директории `app` и `app/templates`, а также скопирует файлы 
шаблонов в корень и переименует их. В прочем, пока это бесполезные файлы и 
папки, мы вернёмся к ним немного позднее. А пока давайте повнимательнее 
разглядим скрипт `app/index.js`.

## Вопросы к пользователю

В первую очередь рассмотрим вопросы, задаваемые пользователю в процессе 
скаффолдинга — это первое, что видит пользователь генератора. 
Как мы успели заметить, сейчас в сценарии содержится всего один 
вопрос и тот бесполезный:

	var prompts = [{
    	type: 'confirm',
    	name: 'someOption',
    	message: 'Would you like to enable this option?',
    	default: true
	}];

Переменная `prompts` является массивом, который содержит отдельные объекты для 
каждого из вопросов, задаваемых пользователю. Вопросы к пользователю в 
*Yeoman* осуществляются с использованием *Inquirer.js*. *Inquirer.js* 
облегчает процесс опроса пользователя и обработки его ответов в Node.js.

Каждый объект-вопрос в массиве `prompts` имеет следующие свойства:

- `type`: (String) Тип вопроса. По умолчанию: `input`. Возможные значения представлены ниже.
- `name`: (String) Имя, используемое для получения значения ответа.
- `message`: (String) Сообщение вопроса, выводимое пользователю.
- `default`: (String|Number|Array|Function) Значение(я) по умолчанию, 
используемые если ничего не было введено или функция, возвращающая значение 
по умолчанию.
- `choices`: (Array|Function) Массив пунктов списка для выбора или функция 
возвращающая такой массив. 
Элементы массива могут быть следующих типов: String или Object. 
Объекты содержат имя (`name`) и значение (`value`) варианта выбора.
- `validate`: (Function) Функция валидации. Принимает в качестве аргумента 
ответ пользователя и возвращает `true`, если значение валидно, и сообщение об 
ошибке в противном случае. Если возвращено значение `false`, выдаётся 
сообщение об ошибке, установленное по умолчанию.
- `filter`: (Function) Функция фильтрации. Принимает в качестве аргумента 
ответ пользователя и возвращает отфильтрованное значение. 
- `when`: (Function) Функция, принимающая объект, содержащий ответы 
пользователя до текущего вопроса и возвращающая `true` или `false`, что 
определяет стоит ли задавать текущий вопрос или нет. 
Это может быть полезно, если 
выдача вопроса зависит от предыдущих вопросов. Тогда метод `when` поможет вам 
сделать выводы на основе результатов ответов пользователя на предыдущие 
вопросы.

## Типы вопросов

Существует несколько типов вопросов к пользователю: `list`, `rawlist`, 
`expand`, `checkbox`, `confirm`, `input` и `password`. 
Все типы вопросов имеют обязательные и опциональные свойства. 
В описании опциональные свойства я обрамлю в квадратные 
скобки (`[]`).

### List — `{ type: "list" }`

Имеет свойства `type`, `name`, `message`, `choices` [, `default`, `filter`]. 
(Помните, что значением по умолчанию (`default`) должен быть индекс элемента 
в массиве пунктов списка `choices`).

![Пример вопроса типа «List»][question-example-list]

### Raw List - `{ type: "rawlist" }`

Имеет свойства `type`, `name`, `message`, `choices`[, `default`, `filter`]. 
(Помните, что значением по умолчанию (`default`) должен быть индекс элемента 
в массиве пунктов списка `choices`).

![Пример вопроса типа «Rawlist»][question-example-rawlist]

### Expand - { type: "expand" }

Имеет свойства `type`, `name`, `message`, `choices`[, `default`, `filter`]. 
(Помните, что значением по умолчанию (`default`) должен быть индекс элемента 
в массиве пунктов списка `choices`).
Имейте ввиду, что объект массива `choices` должен иметь свойство `key`. 
Это свойство должно содержать один печатный символ в нижнем регистре. При этом 
свойство с символом `h` уже добавлено по умолчанию и не следует его 
определять самостоятельно.

![Пример вопроса типа «Expand»][question-example-expand]

### Checkbox - `{ type: "checkbox" }`

Имеет свойства `type`, `name`, `message`, `choices`[, `default`, `filter`, 
`validate`]. Свойство `default` должно быть массивом с элементами, 
указывающими на элементы массива пунктов списка `choices`, которые 
по умолчанию будут считаться выбранными (отмеченными). Также элементы массива 
списка пунктов, отмеченные свойством `checked: true` будут отмечены 
автоматически.

![Пример вопроса типа «Checkbox»][question-example-checkbox]

### Confirm - `{ type: "confirm" }`

Имеет свойства `type`, `name`, `message`[, `default`]. Предполагается, что 
свойство `default` имеет булево значение, если оно определено.

![Пример вопроса типа «Confirm»][question-example-confirm]

### Input - `{ type: "input" }`

Имеет свойства `type`, `name`, `message`[, `default`, `filter`, `validate`].

![Пример вопроса типа «Input»][question-example-input]

### Password - { type: "password" }

Имеет свойства `type`, `name`, `message`[, `default`, `filter`, `validate`].

![Пример вопроса типа «Input»][question-example-input]

Более подробные нюансы использования этого модуля вы можете найти 
[в его официальной документации][question-object] на английском языке.

Согласно требованиям к генератору, я составил массив вопросов, необходимых в 
сценарии:

	var prompts = [{
		type: 'list',
		name: 'framework',
		message: 'Какой фреймворк будем использовать?',
		choices: [{
		    name: 'Foundation 5',
		    value: 'foundation'
		  }, {
		    name: 'Twitter Bootstrap 3',
		    value: 'bootstrap'
		}],
		default: 0
	}, {
		type: 'confirm',
		name: 'sass',
		message: 'Будем использовать Sass?',
		default: true
	}, {
		type: 'checkbox',
		name: 'features',
		message: 'Выбери дополнительные компоненты:',
		choices: [{
			name: 'Modernizr',
			value: 'modernizr',
			checked: true
		}, {
			name: 'Autoprefixer',
			value: 'autoprefixer',
			checked: true
		}]
	}];

## Ответы

Рядом с массивом вопросов можно обнаружить функцию обработки вопросов:

	this.prompt(prompts, function (props) {
    	this.someOption = props.someOption;
	
    	cb();
	}.bind(this));

Метод `prompt` принимает в качестве аргументов массив с вопросами `prompts` и 
функцию, которая описывает как поступить с полученными ответами. 
Объект, который принимает эта функция содержит ответы на вопросы. Ответы — 
это свойства этого объекта, которые носят имена, соответствующие свойству 
`name` объекта вопроса. 
Используя значения по умолчанию к вопросам генератора `frontender` внутри функции будет получен следующий объект `props`:

	{
		framework: 'foundation',
		sass: true,
		features: ['modernizr', 'autoprefixer']
	}

Получение ответов заключается в вынесении этих значений в глобальную область 
видимости для дальнейшего использования. Этим и займёмся:

	this.prompt(prompts, function (props) {
	
		function hasFeature(feat) { return props.features.indexOf(feat) !== -1; }
	
		this.framework = props.framework;
		this.sass = props.sass;
		this.sass = props.sass;
		this.modernizr = hasFeature('modernizr');
		this.autoprefixer = hasFeature('autoprefixer');
	
		cb();
	}.bind(this));

Таким образом мы получаем ответы от пользователя для дальнейшего использования 
их в сценарии и при обработке шаблонов. Функция `hasFeature` — простой способ 
выяснить, присутствует ли каждый из дополнительных компонентов в ответах.

## Кульминация

Теперь мы можем должным образом развернуть проект опираясь на ответы, 
полученные от пользователя. 
Наверняка, в файле `app/index.js` вы уже заметили подобные объявления:

	FrontenderGenerator.prototype.askFor = function askFor() {
     	// …
	};
	
	FrontenderGenerator.prototype.app = function app() {
		// …
	};

В качестве методов прототипа объявляются функции, описывающие действия, 
которые должен выполнять генератор. Важным нюансом является то, что 
объявленные методы будут вызываться в том порядке, в котором они описаны в 
сценарии. Никто не запрещает создать всего один метод, но обычно, действия 
разделяют на отдельные методы для удобного представления. Например, в скрипте 
пока ещё имеется пара методов прототипа:

	FrontenderGenerator.prototype.app = function app() {
		this.mkdir('app');
		this.mkdir('app/templates');
		this.copy('_package.json', 'package.json');
		this.copy('_bower.json', 'bower.json');
	};

	FrontenderGenerator.prototype.projectfiles = function projectfiles() {
		this.copy('editorconfig', '.editorconfig');
		this.copy('jshintrc', '.jshintrc');
	};

В примерах выше приведены два метода работы с файлами в определениях Yeoman: 

- `this.mkdir` создаёт указанную директорию относительно директории,
в которой был запущен процесс скаффолдинга с использованием этого генератора.
- `this.copy` копирует указанный файл. Первым 
параметром принимает имя файла-источника из директории с шаблонами 
генератора — `templates`, вторым параметром — конечное имя файла, включая путь 
к нему относительно директории, в которой выполняется генератор.

Это две наиболее часто употребляемые команды при работе со статичными файлами 
и директориями. Вам возможно ничего другого больше и не понадобится, но на 
всякий случай есть [документация к API][yeoman-generator-api].

## Работа с шаблонами

Первым делом стоит отметить, что в официальной документации предлагается 
именовать файлы-шаблоны с использованием знака подчеркивания в начале. Это 
довольно символично, поскольку в *Yeoman* за обработку шаблонов отвечает 
шаблонизатор [Lo-Dash][lo-dash].

Сам шаблон какого-либо файла будет иметь в коде директивы и 
операторы, воспринимаемые шаблонизатором, вроде таких: `<%= pkg.version %>`. 
Также, вам из сценариев доступны функциональные возможности *Lo-Dash*: 
`<%= _.slugify(someVar) %>`.
Обработка шаблонов закреплена за методом `template`:

	FrontenderGenerator.prototype.app = function app() {
		//…
		this.template('Gruntfile.js', 'Gruntfile.js');
		this.template('index.html', 'index.html');
		//…
	};

Аналогично с функцией `this.copy`, `template` в качестве первого параметра 
принимает имя файла-шаблона в директории `templates`, в качестве второго — имя 
выходного файла, обработанного шаблонизатором.

Шаблонами могут быть любые текстовые файлы как то: `package.json`, 
`bower.json`, другие конфигурационные файлы. Если вам не нравится концепция 
шаблонов, можете писать в файлы непосредственно из генератора 
(метод [this.write()][actions-write]).

Применив вышеперечисленные методы для работы с файлами к генератору 
`frontender`, я получил [довольно объёмные функции][github-link-to-prototype-methods].

## Завершение сценария

Ключевой особенностью скаффолдера *Yeoman* является то, что он тесно 
взаимодействует с *Grunt* и *Bower* в момент инициализации проекта. 
В `index.js` вы найдёте метод установки зависимостей, вызываемый по завершении 
выполнения всех функций сценария:

	this.on('end', function () {
		this.installDependencies({ skipInstall: options['skip-install'] });
	});

Метод `installDependencies` запускает загрузку и установку как npm-пакетов, 
так и Bower-компонентов в случае, если загрузка не отменена опцией 
`skip-install` при запуске скаффолдера. Если установка модулей была отменена 
использованием опции `skip-install`, пользователь вашего генератора сможет 
установить их позднее, выполнив команды установки пакетов для *npm* и *Bower*.
Как я и говорил, `package.json`, `bower.json` и `Gruntfile.js` также 
могут быть шаблонами, 
в них аналогично можно использовать ответы пользователя. 
В генераторе `frontender` они также являются шаблонами и
[доступны для изучения на GitHub][github-examples-of-templates].
 
## Суб-генераторы

Суб-генераторы — это самостоятельные генераторы, не имеющие логического 
предназначения без основного генератора. Отличный пример — генератор и 
суб-генераторы [AngularJS][generator-angular]. В нём суб-генераторы отвечают 
за добавление компонентов приложения, таких как маршруты, контроллеры, 
представления и т.д.
Также суб-генераторы используют для разбиения логики генерации приложения на 
более мелкие самостоятельные части, вызываемые основным генератором. Пример 
такого использования можно найти в генераторе 
[Backbone.js][generator-backbone]. 
Итак, если вашему генератору требуются суб-генераторы, следующие действия 
приведут к желаемому результату.

1. Из директории с вашим генератором выполните: 
`yo generator:subgenerator "name"`, где `name` — имя суб-генератора.
2. Откройте `{name}/index.js`. Структура файла аналогична основному 
генератору, поэтому, написав основной генератор, вам не составит труда 
написать логику суб-генератора. Все правила написания логики генератора, 
описанные ранее, работают и для суб-генераторов.
3. Вызов команды `yo {your_generator}:{your_subgenerator} "args"` приведёт к 
запуску созданного вами суб-генератора `your_subgenerator` генератора 
`your_generator` с аргументами `args`.

## Полезные ссылки и что читать/смотреть дальше

- Первым делом, конечно, 
[официальная документация][yeoman-write-first-generator].
- Не забываем про некоторые 
[полезные сниппеты для написания генератора][yeoman-off-snippets] на 
официальном сайте. 
- По [тегу yeoman на HTML5Rocks][yeoman-on-the-html5roks] можно найти свежие 
выпуски «The Yeoman Monthly Digest», содержащего достаточно много полезных 
туториалов по написанию и использованию различного рода генераторов.
- [Видео по созданию генератора][yeoman-generator-video-1]. Опубликовано в мае 
2013, поэтому может немного отличаться от сегодняшнего Yeoman.
- [Каталог open-source генераторов для Yeoman][yeoman-generators-list].
- [Документация к API генераторов Yeoman][yeoman-generator-api]. В нём описаны 
все методы, доступные для использования в генераторе.


[prompt-types]: https://github.com/SBoudrias/Inquirer.js#prompts-type
[question-object]: https://github.com/SBoudrias/Inquirer.js#question
[yeoman-generator-api]: https://github.com/yeoman/generator/wiki/actions
[lo-dash]: http://lodash.com
[generator-angular]: https://github.com/yeoman/generator-angular#generators
[generator-backbone]: https://github.com/yeoman/generator-backbone/blob/master/all/index.js#L33
[yeoman-write-first-generator]: http://yeoman.io/generators.html#writing-your-first-generator
[yeoman-on-the-html5roks]: http://updates.html5rocks.com/tag/yeoman
[yeoman-generator-video-1]: https://www.youtube.com/watch?v=q-KRiwXhbhU
[yeoman-generators-list]: http://yeoman.io/community-generators.html
[actions-write]: https://github.com/yeoman/generator/wiki/actions#actionswrite
[Yeoman]: img/yeoman.png "Yeoman"
[Yeoman-generator-example]: img/generator.png "Пример работы генератора Yeoman"
[my-old-article]: http://frontender.info/skaffolding-dlya-frontenderov/
[yeoman-off-snippets]: http://yeoman.io/generators.html#snippets
[question-example-list]: img/question-example-list.png "Пример вопроса типа «List»"
[question-example-rawlist]: img/question-example-rawlist.png "Пример вопроса типа «Rawlist»"
[question-example-checkbox]: img/question-example-checkbox.png "Пример вопроса типа «Checkbox»"
[question-example-confirm]: img/question-example-confirm.png "Пример вопроса типа «Confirm»"
[question-example-expand]: img/question-example-expand.png "Пример вопроса типа «Expand»"
[question-example-input]: img/question-example-input.png "Пример вопроса типа «Input»"
[question-example-password]: img/question-example-password.png "Пример вопроса типа «Password»"
[generator-init]: img/generator-init.png "Инициализация нового генератора"
[github-link-to-prototype-methods]: https://github.com/lancedikson/generator-frontender/blob/master/app/index.js#L76
[github-examples-of-templates]: https://github.com/lancedikson/generator-frontender/tree/master/app/templates
